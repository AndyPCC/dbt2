#!/bin/bash

#
# This file is released under the terms of the Artistic License.
# Please see the file LICENSE, included in this package, for details.
#
# Copyright (C) 2002-2006 Mark Wong & Open Source Development Labs, Inc.
#

abs_top_srcdir=@abs_top_srcdir@
DBDIR=@database_to_use@

DIR=`dirname $0`
source ${DIR}/dbt2_profile || exit 1

trap 'echo "Test was interrupted by Control-C."; \
	killall client; killall driver; killall sar; killall sadc; killall vmstat; killall iostat; $abs_top_srcdir/scripts/${DBDIR}/stop_db.sh' INT
trap 'echo "Test was interrupted. Got TERM signal."; \
	killall client; killall driver;  killall sar; killall sadc; killall vmstat; killall iostat; $abs_top_srcdir/scripts/${DBDIR}/stop_db.sh' TERM

usage()
{
	if [ "$1" != "" ]; then
		echo
		echo "error: $1"
	fi
	echo ''
	echo 'usage: run_workload.sh -c <number of database connections> -d <duration of test> -w <number of warehouses>'
	echo 'other options:'
	echo '       -n <database name. (default dbt2)>'
	echo '       -h <database host name. (default localhost)>'
	echo '       -l <database port number>'
	echo '       -o <enable oprofile data collection>'
	echo '       -s <delay of starting of new threads in milliseconds>'
	echo '       -n <no thinking or keying time (default no)>'
	if [ "$DBDIR" == "mysql" ]; then
	echo '       -u <database user>'
	echo '       -x <database password>'
	fi
	echo '       -z <comments for the test>'
	echo ''
	echo 'Example: sh run_workload.sh -c 20 -d 100 -w 1'
	echo 'Test will be run for 120 seconds with 20 database connections and scale factor (num of warehouses) 1'
	echo ''
}

validate_parameter()
{
	if [ "$2" != "$3" ]; then
		usage "wrong argument '$2' for parameter '-$1'"
		exit 1
	fi
}

do_sleep()
{
	echo "Sleeping $1 seconds"
	sleep $1
}

DB_HOSTNAME="localhost"
DB_PASSWORD=""
DB_PARAMS=""
if [ ${DBDIR} == "pgsql" ]; then
	DB_PORT=5432
elif [ ${DBDIR} == "mysql" ]; then
	DB_PORT=""
fi
DB_USER=${DBUSER}
SLEEPY=1000 # milliseconds
USE_OPROFILE=0
THREADS_PER_WAREHOUSE=10

while getopts "c:d:l:nop:s:t:u:w:x:z:" opt; do
	case $opt in
	c)
		# Check for numeric value
		DBCON=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DBCON
		;;
	d)
		DURATION=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DURATION
		;;
	l)
		DB_PORT=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $DB_PORT
		;;
	n)
		NO_THINK="-ktd 0 -ktn 0 -kto 0 -ktp 0 -kts 0 -ttd 0 -ttn 0 -tto 0 -ttp 0 -tts 0"
		;;
	o)
		USE_OPROFILE=1
		;;
	p)
		DB_PARAMS=$OPTARG
		;;
	s)
		SLEEPY=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $SLEEPY
		;;
	t)
		THREADS_PER_WAREHOUSE=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $THREADS_PER_WAREHOUSE
		;;
	u)      
		DB_USER=${OPTARG}
		;;

	w)
		WAREHOUSES=`echo $OPTARG | egrep "^[0-9]+$"`
		validate_parameter $opt $OPTARG $WAREHOUSES
		;;
	x)      
		DB_PASSWORD=${OPTARG}
		;;

	z)
		COMMENT=$OPTARG
		;;
	esac
done

# Check parameters.

if [ "$DBCON" == "" ]; then
	echo "specify the number of database connections using -c #"
	exit 1
fi

if [ "$DURATION" == "" ]; then
	echo "specify the duration of the test in seconds using -d #"
	exit 1
fi

if [ "$WAREHOUSES" == "" ]; then
	echo "specify the number of warehouses using -w #"
	exit 1
fi

if [ $(( $THREADS_PER_WAREHOUSE*1 )) -lt 1 -o $(( $THREADS_PER_WAREHOUSE*1 )) -gt 1000 ]; then
	usage "-t value should be in range [1..1000]. Please specify correct value"
	exit 1
fi

ULIMIT_N=`ulimit -n`
ESTIMATED_ULIMIT=$(( 2*${WAREHOUSES}*${THREADS_PER_WAREHOUSE}+${DBCON} ))
if [ ${ULIMIT_N} -lt $(( $ESTIMATED_ULIMIT )) ]; then
  usage "you're open files ulimit is too small, must be at least ${ESTIMATED_ULIMIT}"
  exit 1
fi

# Determine the output directory for storing data.
RUN_NUMBER=-1
RUN_FILE="${abs_top_srcdir}/scripts/run_number"
if test -f ${RUN_FILE}; then
  read RUN_NUMBER < ${RUN_FILE}
fi
if [ $RUN_NUMBER -eq -1 ]; then
	RUN_NUMBER=0
fi
OUTPUT_DIR=${abs_top_srcdir}/scripts/output/${RUN_NUMBER}
CLIENT_OUTPUT_DIR=$OUTPUT_DIR/client
DRIVER_OUTPUT_DIR=$OUTPUT_DIR/driver
DB_OUTPUT_DIR=$OUTPUT_DIR/db

# Create the directories we will need.
mkdir -p $OUTPUT_DIR
mkdir -p $CLIENT_OUTPUT_DIR
mkdir -p $DRIVER_OUTPUT_DIR
mkdir -p $DB_OUTPUT_DIR

# Update log.html
echo "<a href='$RUN_NUMBER/'>$RUN_NUMBER</a>: $COMMENT<br />" >> ${abs_top_srcdir}/scripts/output/log.html

# Update the run number for the next test.
RUN_NUMBER=`expr $RUN_NUMBER + 1`
echo $RUN_NUMBER > ${RUN_FILE}

# Create a readme file in the output directory and date it.
date >> $OUTPUT_DIR/readme.txt
echo "$COMMENT" >> $OUTPUT_DIR/readme.txt
uname -a >> $OUTPUT_DIR/readme.txt
echo "Command line: $0 $@" >> $OUTPUT_DIR/readme.txt

# Get any OS specific information.
OS_DIR=`uname`
$abs_top_srcdir/scripts/$OS_DIR/get_os_info.sh -o $OUTPUT_DIR

# Output run information into the readme.txt.
echo "Database Scale Factor: $WAREHOUSES warehouses" >> $OUTPUT_DIR/readme.txt
echo "Test Duration: $DURATION seconds" >> $OUTPUT_DIR/readme.txt
echo "Database Connections: $DBCON" >> $OUTPUT_DIR/readme.txt

$abs_top_srcdir/scripts/${DBDIR}/stop_db.sh
START_DB_ARGS=""
if [ ${DBDIR} == "pgsql" ]; then
	if [ -n "${DB_PARAMS}" ]; then
		START_DB_ARGS="${START_DB_ARGS} -p \"${DB_PARAMS}\""
	fi
fi
START_DB_ARGS="${START_DB_ARGS} -o ${DB_OUTPUT_DIR}"
${abs_top_srcdir}/scripts/${DBDIR}/start_db.sh ${START_DB_ARGS} || exit 1

#
# Redisplay the test parameters.
#
echo "************************************************************************"
echo "*		     DBT-2 test for ${DBDIR} started		     *"
echo "*								      *"
echo "*	    Results can be found in output/$(( $RUN_NUMBER-1 )) directory	       *"
echo "************************************************************************"
echo "*								      *"
echo "*  Test consists of 3 stages:					  *"
echo "*								      *"
echo "*  1. Start of client to create pool of databases connections	  *"
echo "*  2. Start of driver to emulate terminals and transactions generation *"
echo "*  3. Processing of results					    *"
echo "*								      *"
echo "************************************************************************"

#
# Build up the client command line arguments.
#

echo ""
echo "DATABASE NAME:		${DBNAME}"

if [ -n "${DB_USER}" ]; then
  echo "DATABASE USER:		${DB_USER}"
  CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -u ${DB_USER}"
fi 

if [ -n "${DB_PASSWORD}" ]; then 
  echo "DATABASE PASSWORD:	    *******" 
  CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -a ${DB_PASSWORD}"
fi 

if [ -n "${DB_SOCKET}" ]; then 
  echo "DATABASE SOCKET:	      ${DB_SOCKET}"
  CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -t ${DB_SOCKET}"
fi 

if [ -n "${DB_PORT}" ]; then 
  echo "DATABASE PORT:		${DB_PORT}"
  CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -l ${DB_PORT}"
fi 

THREADS=$(( ${WAREHOUSES}*${THREADS_PER_WAREHOUSE} ))
echo "DATABASE CONNECTIONS:	 ${DBCON}"
echo "TERMINAL THREADS:	     ${THREADS}"
echo "TERMINALS PER WAREHOUSE:      ${THREADS_PER_WAREHOUSE}"
echo "SCALE FACTOR(WARHOUSES):      ${WAREHOUSES}"
echo "DURATION OF TEST (in sec):     ${DURATION}"
echo "1 client stared every ${SLEEPY} millisecond(s)"
echo ""

#
# Start the client.
#
echo "Stage 1. Starting up client..."
if [ ${DBDIR} == "pgsql" ]; then
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -d ${DB_HOSTNAME}"
elif [ ${DBDIR} == "mysql" ]; then
	CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -d ${DBNAME} -t /tmp/mysql.sock"
fi
CLIENT_COMMAND_ARGS="${CLIENT_COMMAND_ARGS} -f -c ${DBCON} -s ${SLEEPY} -o ${CLIENT_OUTPUT_DIR}"
LD_LIBRARY_PATH=@LIBDIR@ ${abs_top_srcdir}/src/client ${CLIENT_COMMAND_ARGS} > ${OUTPUT_DIR}/client.out 2>&1 || exit 1 &

# Sleep long enough for all the client database connections to be established.
SLEEPYTIME=$(( (1+$DBCON)*$SLEEPY/1000 ))
do_sleep $SLEEPYTIME

# Start collecting data before we start the test.
SLEEP_RAMPUP=$(( (($WAREHOUSES+1)*10*$SLEEPY/1000) ))
SLEEPYTIME=$(( $SLEEP_RAMPUP+$DURATION ))
SAMPLE_LENGTH=60
ITERNATIONS=$(( ($SLEEPYTIME/$SAMPLE_LENGTH)+1 ))
$abs_top_srcdir/scripts/sysstats.sh --iter $ITERNATIONS --sample $SAMPLE_LENGTH --outdir $OUTPUT_DIR > $OUTPUT_DIR/stats.out 2>&1 &
$abs_top_srcdir/scripts/${DBDIR}/db_stat.sh -o $DB_OUTPUT_DIR -i $ITERNATIONS -s $SAMPLE_LENGTH > $OUTPUT_DIR/dbstats.out 2>&1 &

# Initialize oprofile before we start the driver.
if [ $USE_OPROFILE -eq 1 ]; then
	sudo opcontrol --vmlinux=/usr/src/linux-`uname -r`/vmlinux -c 100
	sleep 1
	sudo opcontrol --start-daemon
	sleep 1
	sudo opcontrol --start
fi

# Start the driver.
echo ''
echo "Stage 2. Starting up driver..."
echo "${SLEEPY} threads started per millisecond"

DRIVERS=$(( $THREADS_PER_WAREHOUSE*$WAREHOUSES ))
DRIVER_COMMAND_ARGS="-d $DB_HOSTNAME -l $DURATION -wmin 1 -wmax $WAREHOUSES -w $WAREHOUSES -sleep $SLEEPY -outdir $DRIVER_OUTPUT_DIR -tpw $THREADS_PER_WAREHOUSE $NO_THINK"
LD_LIBRARY_PATH=@LIBDIR@ ${abs_top_srcdir}/src/driver ${DRIVER_COMMAND_ARGS} > ${OUTPUT_DIR}/driver.out 2>&1 || exit 1&

do_sleep $SLEEP_RAMPUP

# Clear the readprofile data after the driver ramps up.
if [ -f /proc/profile ]; then
	echo "Clearing profile data"
	sudo /usr/sbin/readprofile -r
fi

# Reset the oprofile counters after the driver ramps up.
if [ $USE_OPROFILE -eq 1 ]; then
	echo "Reseting oprofile counters"
	sudo opcontrol --reset
fi

# Sleep for the duration of the run.
do_sleep $DURATION

# Collect profile data.
if [ -f /proc/profile ]; then
	PROFILE=$OUTPUT_DIR/readprofile.txt
	/usr/sbin/readprofile -n -m /boot/System.map-`uname -r` > $PROFILE
	cat $PROFILE | sort -n -r -k1 > $OUTPUT_DIR/readprofile_ticks.txt
	cat $PROFILE | sort -n -r -k3 > $OUTPUT_DIR/readprofile_load.txt
fi

# Collect oprofile data.
if [ $USE_OPROFILE -eq 1 ]; then
	sudo opcontrol --dump
	sudo opreport -l -p /lib/modules/`uname -r` -o $OUTPUT_DIR/oprofile.txt
	sudo opreport -l -c -p /lib/modules/`uname -r` -o $OUTPUT_DIR/callgraph.txt
	sudo opcontrol --stop
fi

echo ''
echo "Stage 3. Processing of results..."

# Run some post processing analysese.
$abs_top_srcdir/scripts/mix_analyzer.pl --infile $DRIVER_OUTPUT_DIR/mix.log --outdir $DRIVER_OUTPUT_DIR > $DRIVER_OUTPUT_DIR/results.out
cp -p $abs_top_srcdir/scripts/notpm.input $DRIVER_OUTPUT_DIR
cd $DRIVER_OUTPUT_DIR
if [ "x@GNUPLOT@" != "x" ]; then
	@GNUPLOT@ notpm.input
fi
cd -

if [ $USE_OPROFILE -eq 1 ]; then
	mkdir -p $OUTPUT_DIR/oprofile/
	mkdir -p $OUTPUT_DIR/oprofile/annotate
	sudo opannotate --source --assembly > $OUTPUT_DIR/oprofile/assembly.txt 2>&1
	sudo opannotate --source --output-dir=$OUTPUT_DIR/oprofile/annotate
fi

# Client doesn't go away by itself like the driver does, so kill it.
echo "Killing client..."
killall client driver 2> /dev/null

$abs_top_srcdir/scripts/${DBDIR}/stop_db.sh

# Change the permissions on the database log, not readable by other users by
# default.  (No, not the transaction log.)
chmod 644 ${DB_OUTPUT_DIR}/log

# Postprocessing of Database Statistics
if [ -f ${OUTPUT_DIR}/sar_raw.out ]; then
	@SAR@ -f ${OUTPUT_DIR}/sar_raw.out -A > ${OUTPUT_DIR}/sar.out
fi
if [ "x@GNUPLOT@" != "x" ]; then
	$abs_top_srcdir/scripts/vmplot.sh -i ${OUTPUT_DIR}/vmstat.out \
			-o ${OUTPUT_DIR}/plots
fi
if [ -f "${abs_top_srcdir}/scripts/${DBDIR}/analyze_stats.pl" ]; then
	${abs_top_srcdir}/scripts/${DBDIR}/analyze_stats.pl --dir ${DB_OUTPUT_DIR}
fi

# Create summary in HTML.
$abs_top_srcdir/scripts/gen_html.sh $OUTPUT_DIR

echo "Test completed."
echo "Results are in: $OUTPUT_DIR"
echo

cat $DRIVER_OUTPUT_DIR/results.out

#!/bin/sh

# run_test.sh
#
# This file is released under the terms of the Artistic License.  Please see
# the file LICENSE, included in this package, for details.
#
# Copyright (C) 2002 Mark Wong & Open Source Development Lab, Inc.
#
# 18 october 2002



# Valid database list
VALIDDBS="pgsql sapdb"

####
##
## FUNCTION LIST
##
####

####
# usage()
#
# Display how to use the script to the user
usage(){
    echo "usage: run_test.sh --db <database> --duration <sec> --sample <sec> -w <warehouses>"
	echo ""
	echo "	<database> includes:"
	for db in ${VALIDDBS} ; do
		echo "		${db}"
	done
    exit 1
}

####
##
## PROGRAM EXECUTION
##
####
PFX=`dirname $0`

# Display help if the wrong number of arguments was supplied.
if [ $# -lt 8 ]; then
	usage
fi

while :
do
	case $# in
	0)
		break
		;;
	esac

	option=$1
	shift

	orig_option=$option
	case $option in
	--*)
		;;
	-*)
		option=-$option
		;;
	esac

	case $option in
	--*=*)
		optarg=`echo $option | sed -e 's/^[^=]*=//'`
		arguments="$arguments $option"
		;;
	--db | --sample | --duration | --wmin | --wmax | --warehouses | --ktd | --ktn | --kto | --ktp | --kts | --ttd | --ttn | --tto | --ttp | --tts | --tpw)
		optarg=$1
		shift
		arguments="$arguments $option=$optarg"
		;;
	esac

	case $option in
	--db)

		# Test to see if this database exists (directory)
		for db in ${VALIDDBS} ; do
			if [ "${db}" = "${optarg}" ]; then
				DBTYPE="$optarg"
			fi
		done

		if [ -z ${DBTYPE} ] ; then
			echo "Database ${optarg} is invalid"
			echo 
			usage
		fi
		;;
	--duration)
		DURATION=$optarg
		;;
	--sample)
		SAMPLE_LENGTH=$optarg
		;;
	--wmin)
		WMIN=$optarg
		;;
	--wmax)
		WMAX=$optarg
		;;
	--warehouses)
		W=$optarg
		;;
	--ktd)
		KTD=$optarg
		;;
	--ktn)
		KTN=$optarg
		;;
	--kto)
		KTO=$optarg
		;;
	--ktp)
		KTP=$optarg
		;;
	--kts)
		KTS=$optarg
		;;
	--ttd)
		TTD=$optarg
		;;
	--ttn)
		TTN=$optarg
		;;
	--tto)
		TTO=$optarg
		;;
	--ttp)
		TTP=$optarg
		;;
	--tts)
		TTS=$optarg
		;;
	--tpw)
		TPW=$optarg
		;;
	esac
done





ITERATION=`expr $DURATION / $SAMPLE_LENGTH`

# determine run number for selecting an output directory
RUN_NUMBER=-1
read RUN_NUMBER < .run_number
if [ $RUN_NUMBER -eq -1 ]; then
	RUN_NUMBER=0
fi
mkdir -p output
mkdir -p output/$RUN_NUMBER
OUTPUT_DIR=output/$RUN_NUMBER
RUN_NUMBER=`expr $RUN_NUMBER + 1`
echo $RUN_NUMBER > .run_number

# Capture a comment.
echo "Enter a short description about this run:"
read COMMENT
echo "$COMMENT" >> $OUTPUT_DIR/readme.txt

# start the database
${PFX}/${DBTYPE}/start_db.sh

# SapDB has a plan file -- run it to generate query plans.
#
# PostgreSQL uses the EXECUTE style which stores plans on the 
# server side.  These need to be handled by the client.
if [ -f ${PFX}/../../${DBTYPE}/plan.sh ] ; then
	cd $OUTPUT_DIR
	${SHELL} ${PFX}/../../${DBTYPE}/plan.sh > plan0.out
	cd -
fi

# start system stat gathering
${SHELL} ${PFX}/sysstats.sh --db ${DBTYPE} --dbname dbt2 --outdir $OUTPUT_DIR --iter $ITERATION --sample $SAMPLE_LENGTH &

# start a test run
CMD="${PFX}/../terminal/driver -d dbt2 -w $W -l $DURATION"

# generate the command line argument for the driver depending on the
# flags used
if [ -z $WMIN ]; then
	WMIN=1
fi
CMD="$CMD -wmin $WMIN"

if [ -z $WMAX ]; then
	WMAX=1
fi
CMD="$CMD -wmax $WMAX"

if ! [ -z $KTD ]; then
	CMD="$CMD -ktd $KTD"
fi

if ! [ -z $KTN ]; then
	CMD="$CMD -ktn $KTN"
fi

if ! [ -z $KTO ]; then
	CMD="$CMD -kto $KTO"
fi

if ! [ -z $KTP ]; then
	CMD="$CMD -ktp $KTP"
fi

if ! [ -z $KTS ]; then
	CMD="$CMD -kts $KTS"
fi

if ! [ -z $TTD ]; then
	CMD="$CMD -ttd $TTD"
fi

if ! [ -z $TTN ]; then
	CMD="$CMD -ttn $TTN"
fi

if ! [ -z $TTO ]; then
	CMD="$CMD -tto $TTO"
fi

if ! [ -z $TTP ]; then
	CMD="$CMD -ttp $TTP"
fi

if ! [ -z $TTS ]; then
	CMD="$CMD -tts $TTS"
fi

if ! [ -z $TPW ]; then
	CMD="$CMD -tpw $TPW"
fi

# start oprofile 
# sudo ./oprof.sh /vmlinux 300000 $DURATION oprofile $OUTPUT_DIR &

# start the driver
$CMD

# copy the terminal output files to the output directory
echo "moving mix.log and error.log"
mv mix.log $OUTPUT_DIR/
mv error.log $OUTPUT_DIR/
exit;
# analyze the results of mix.log
perl mix_analyzer.pl --infile $DRIVER_OUTPUT_DIR/mix.log --outdir $DRIVER_OUTPUT_DIR > $DRIVER_OUTPUT_DIR/results.out

echo "run complete"

# stop the database
${DBTYPE}/stop_db.sh

# draw graphs
cd $OUTPUT_DIR
@GNUPLOT@ ../../notpm.input
